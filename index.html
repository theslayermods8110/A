<!DOCTYPE html>
<html>
<head>
<title>APK Scan (Optimized ~300 lines + Copy All)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.min.css">
<style>
:root { --font-size: .95em; }
body { padding: 15px; font-size: var(--font-size); }
main { max-width: 900px; margin: 20px auto; }
.input-area { text-align: center; margin-bottom: 1.5rem; padding: 1rem; border: 1px dashed var(--muted-border-color); background-color: var(--contrast-hover-background); border-radius: var(--border-radius); }
#file-name { font-style: italic; color: var(--muted-color); margin-top: .5rem; display: block; min-height: 1.2em; }
#loader { border: 4px solid var(--contrast); border-top: 4px solid var(--primary); border-radius: 50%; width: 20px; height: 20px; animation: spin 1s linear infinite; display: none; margin: 10px auto; }
@keyframes spin { 0%{transform:rotate(0deg)} 100%{transform:rotate(360deg)} }
#error-message { color: var(--form-element-invalid-border-color); font-weight: 700; text-align: center; margin-top: 10px; min-height: 1.2em; }
#results-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: .8rem; }
#results-header h2 { margin-bottom: 0; font-size: 1.2em; }
#results-placeholder { color: var(--muted-color); text-align: center; padding: 2rem; font-style: italic; }
.finding-section { margin-bottom: 1rem; padding: 1rem; border: 1px solid var(--card-border-color); border-radius: var(--card-border-radius); background: var(--card-background-color); }
.finding-section h3 { margin-top: 0; margin-bottom: .5rem; color: var(--primary); border-bottom: 1px solid var(--muted-border-color); padding-bottom: .3rem; font-size: 1.1em; }
.finding-section h3 span.count-badge { font-size: .8em; padding: 2px 5px; border-radius: 3px; vertical-align: middle; font-weight: 400; margin-left: 5px; display: inline-block; line-height: 1; }
.finding-section ul { list-style: none; padding-left: 0; max-height: 400px; overflow-y: auto; margin: 0; }
.finding-section li { margin-bottom: 6px; padding: 4px 2px; border-bottom: 1px dotted var(--muted-border-color); word-wrap: break-word; font-family: monospace; display: flex; flex-direction: column; font-size: .9em; }
.finding-section li:last-child { border-bottom: none; }
.finding-value { padding: 2px 4px; border-radius: 3px; display: inline-block; margin-right: 10px; line-height: 1.3; font-weight: 500; cursor: pointer; }
.finding-location { font-size: .85em; color: var(--muted-color); margin-top: 3px; font-family: var(--font-family); white-space: pre-wrap; }
.no-findings { color: var(--muted-color); text-align: center; padding: 10px; }
.hl-critical { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
.hl-high { background-color: #fff3cd; color: #856404; border: 1px solid #ffeeba; }
.hl-medium { background-color: #ffe082; color: #c66900; border: 1px solid #ffca28; }
.hl-low { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
.hl-info { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
.hl-data { background-color: #e2e3e5; color: #383d41; border: 1px solid #d6d8db; }
#progress-text { font-size: .9em; color: var(--muted-color); text-align: center; margin-top: 5px; height: 1.2em; }
#scan-footer-text { text-align: center; font-size: .8em; color: var(--muted-color); margin-top: 1rem; }
#manifest-info { margin-bottom: 1rem; padding: 1rem; border: 1px solid var(--card-border-color); border-radius: var(--card-border-radius); background: var(--card-background-color); font-size: 0.9em;}
#manifest-info h3 { margin-top: 0; margin-bottom: .5rem; color: var(--h3-color); font-size: 1.1em; }
#manifest-info .debuggable-true { color: var(--form-element-invalid-border-color); font-weight: bold; }
#privacy-notice { font-size: 0.8em; text-align: center; color: var(--muted-color); margin-top: 1.5rem; border-top: 1px solid var(--muted-border-color); padding-top: 0.5rem; }
</style>
</head>
<body>
<main>
    <h1>APK Scan (Optimized)</h1>
    <div class="input-area">
        <label for="apk-file-input" role="button" class="contrast">Select APK</label>
        <input type="file" id="apk-file-input" accept=".apk" style="display: none;">
        <span id="file-name">No file chosen</span>
        <button id="analyze-button" disabled>Analyze</button>
        <div id="loader"></div>
        <div id="progress-text"></div>
        <div id="error-message"></div>
    </div>
    <div id="results">
        <div id="results-header">
             <h2>Results:</h2>
             <button id="copy-all-button" class="secondary" style="display: none; margin-left: 10px;" title="Copy all found items to clipboard">Copy All Results</button>
        </div>
        <div id="manifest-info" style="display: none;"></div>
        <div id="results-content"><p id="results-placeholder" class="results-placeholder">Ready. Select APK file.</p></div>
        <div id="scan-footer-text"></div>
    </div>
    <div id="privacy-notice">
        ðŸ”’ **Privacy Guaranteed:** This entire analysis runs <strong>locally in your browser</strong>. Your APK file is <strong>never</strong> uploaded or sent anywhere.
    </div>
</main>

<script>
const MIN_STRING_LEN_DEX = 6;
const RENDER_BATCH_SIZE = 75;
const MAX_DISPLAY_VALUE_LEN = 250;
const MAX_FILES_PER_FINDING_DISPLAY = 5;
const ANALYSIS_YIELD_INTERVAL = 50; // Yield after processing this many files

const fileInput = document.getElementById('apk-file-input');
const analyzeButton = document.getElementById('analyze-button');
const resultsContent = document.getElementById('results-content');
const loader = document.getElementById('loader');
const fileNameDisplay = document.getElementById('file-name');
const errorMessage = document.getElementById('error-message');
const progressText = document.getElementById('progress-text');
const scanFooterText = document.getElementById('scan-footer-text');
const manifestInfoContainer = document.getElementById('manifest-info');
const resultsPlaceholder = document.getElementById('results-placeholder');
const resultsHeader = document.querySelector('#results h2');
const copyAllButton = document.getElementById('copy-all-button');

const PATTERNS = {
    PRIVATE_KEY: { regex: /-----BEGIN ((RSA|OPENSSH|PGP|DSA|EC) )?PRIVATE KEY-----/g, l: "Private Keys Found", h: "hl-critical", p: 1, mt: 'block' },
    AWS_SECRET: { regex: /\b(?!AKIA|ASIA)[A-Za-z0-9\/+=]{40}\b/g, l: "Potential AWS Secret Keys", h: "hl-critical", p: 1, f: v => v.length === 40 && /[a-zA-Z]/.test(v) && /[0-9]/.test(v) && !/^[A-F0-9]+$/i.test(v) },
    SENSITIVE_KW_LINE: { regex: /^.*?\b(password|passwd|pwd|secret|token|api[-_]?key|auth[-_]?key|access[-_]?key|private[-_]?key|credential|client[-_]?secret|bearer|contraseÃ±a|clave)\b.*$/gmi, l: "Lines w/ Sensitive Keywords", h: "hl-critical", p: 1, mt: 'line', f: v => !v.toLowerCase().includes('example') && !v.toLowerCase().includes('placeholder') && v.trim().length > 10 },
    JWT: { regex: /\b(ey[a-zA-Z0-9_-]{5,}\.ey[a-zA-Z0-9_-]{5,}\.(?:[a-zA-Z0-9_-]{10,}))\b/g, l: "JSON Web Tokens (JWT)", h: "hl-high", p: 2 },
    AWS_KEY: { regex: /\b(AKIA|ASIA)[0-9A-Z]{16}\b/g, l: "AWS Access Key IDs", h: "hl-high", p: 2 },
    GOOGLE_API_KEY: { regex: /AIza[A-Za-z0-9_\-]{35}/g, l: "Google API Keys", h: "hl-high", p: 2 },
    SLACK_TOKEN: { regex: /\b(xox[pbar])-[0-9a-zA-Z]{20,}\b/g, l: "Slack Tokens", h: "hl-high", p: 2 },
    STRIPE_KEY: { regex: /\b([sr]k_(live|test)_[0-9a-zA-Z]{24})\b/g, l: "Stripe Keys", h: "hl-high", p: 2 },
    FIREBASE_URL: { regex: /[a-zA-Z0-9\-]+\.firebaseio\.com/g, l: "Firebase Realtime DB URLs", h: "hl-medium", p: 3 },
    SSH_RSA: { regex: /\b(ssh-rsa AAAA[0-9A-Za-z+\/]+[=]{0,3})\b/g, l: "SSH RSA Public Keys", h: "hl-medium", p: 3 },
    DB_CONNECTION: { regex: /\b(jdbc|mysql|postgres|sqlserver|mongodb(?:srv)?):\/\/.*/gi, l: "Potential DB Conn Strings", h: "hl-medium", p: 3, mt: 'line' },
    GENERIC_API_KEY: { regex: /\b([a-zA-Z0-9]{20,64})\b/g, l: "Generic API Key Patterns", h: "hl-medium", p: 3, f: v => !/^[0-9]+$/.test(v) && !/^[a-fA-F0-9]+$/.test(v) && !/^[A-Za-z]+$/.test(v) && /[a-z]/.test(v) && /[A-Z]/.test(v) && /[0-9]/.test(v) && v.length >= 20 },
    HIGH_ENTROPY: { regex: /\b[a-zA-Z0-9\/+_-]{32,}\b/g, l: "High Entropy Strings (>= 32)", h: "hl-low", p: 4, f: v => !/^[0-9]+$/.test(v) && !/^[a-fA-F0-9]+$/i.test(v) && !v.includes(' ') && !v.startsWith('http') && v.length < 100 },
    CLOUD_STORAGE: { regex: /\b(s3\.amazonaws\.com|[a-zA-Z0-9.-]+\.s3[.-][a-z0-9-]+.amazonaws\.com|[a-zA-Z0-9-]+\.storage\.googleapis\.com|[a-zA-Z0-9]+\.blob\.core\.windows\.net)\b/gi, l: "Cloud Storage URLs", h: "hl-low", p: 4 },
    IPV4: { regex: /\b(?:(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])\b/g, l: "Public IPv4 Addresses", h: "hl-low", p: 4, f: ip => !/^(127\.0\.0\.1|0\.0\.0\.0|10\.|192\.168\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|169\.254\.)/.test(ip) && ip !== '255.255.255.255' },
    IPV6: { regex: /((([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])))/gi, l: "Public IPv6 Addresses", h: "hl-low", p: 4, f: ip => ip !== '::1' && !ip.toLowerCase().startsWith('fe80:') && !ip.toLowerCase().startsWith('fc') && !ip.toLowerCase().startsWith('fd') && !ip.startsWith('::') },
    EMAIL: { regex: /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g, l: "Emails", h: "hl-info", p: 5, f: e => !/(example|placeholder|test)\.(com|org|net)$/i.test(e) && !e.includes('@localhost') && !e.includes('@domain.') },
    URL: { regex: /https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)/gi, l: "URLs", h: "hl-info", p: 5, f: u => u.length > 12 && !/(schemas\.android\.com|schemas\.google\.com|google\.com\/.*?(?:ads|analytics)|w3\.org|xmlpull\.org|localhost|jetbrains\.com|facebook\.com|twitter\.com|linkedin\.com|github\.com)/i.test(u) },
    BASE64_LIKE: { regex: /\b(?:[A-Za-z0-9+\/]{16,}={0,2})\b/g, l: "Potential Base64 (>= 16)", h: "hl-data", p: 6, f: v => v.length % 4 === 0 && v.length >= 16 && !/^[a-fA-F0-9]+$/.test(v) && !/^[0-9]+$/.test(v) && /[a-zA-Z]/.test(v) && /[0-9]/.test(v) }
};
const compiledPatterns = Object.entries(PATTERNS).map(([type, pt]) => ({ ...pt, type, compiledRegex: new RegExp(pt.regex) }));

let selectedFile = null;
let isAnalyzing = false;
let lastAnalysisResults = null;

function escapeHtml(unsafe) { return unsafe ? unsafe.replace(/</g, "<").replace(/>/g, ">") : ""; }

function extractStringsFromBuffer(buffer, minLength) {
    const uint8Array = new Uint8Array(buffer); const result = []; let currentString = '';
    for (let i = 0; i < uint8Array.length; i++) { const charCode = uint8Array[i];
        if ((charCode >= 32 && charCode <= 126) || charCode === 9 || charCode === 10 || charCode === 13) { currentString += String.fromCharCode(charCode); }
        else { if (currentString.length >= minLength) result.push(currentString); currentString = ''; } }
    if (currentString.length >= minLength) result.push(currentString); return result.join('\n'); }

function isInterestingTextFileName(fileName) {
    const lfn = fileName.toLowerCase(); const exts = ['.txt','.json','.xml','.html','.js','.css','.properties','.cfg','.ini','.md','.yaml','.yml','.pem','.crt','.key','.log','.conf','.config','.sql','.sh','.bat','.ps1','.gradle','.xcscheme','.plist','.strings','.env'];
    const names = ['readme','license','config','setting','credential','token','key','note','todo','secret'];
    if (exts.some(ext => lfn.endsWith(ext))) return true; if (lfn.lastIndexOf('.') === -1 && names.some(name => lfn.includes(name))) return true;
    if (lfn.endsWith('/strings.xml') || lfn.includes('settings.xml') || lfn.includes('config.xml')) return true; return false; }

function findContextLine(content, matchIndex) {
    try { let lineStart = content.lastIndexOf('\n', matchIndex - 1) + 1; let lineEnd = content.indexOf('\n', matchIndex); if (lineEnd === -1) lineEnd = content.length;
        const line = content.substring(lineStart, lineEnd).trim(); const lineNumber = content.substring(0, matchIndex).split('\n').length; return { line, lineNumber };
    } catch { return { line: "[Context extraction failed]", lineNumber: 0 }; } }

function scanContent(content, fileName, isDex, allFindings) {
    if (!content || typeof content !== 'string') return; const lines = content.split('\n');
    for (const pt of compiledPatterns) { const regex = pt.compiledRegex; let match; regex.lastIndex = 0;
        try {
            if (pt.mt === 'block' && regex.test(content)) { regex.lastIndex = 0; match = regex.exec(content); if (match) { const cleanValue = match[0].trim();
                    if (pt.f && !pt.f(cleanValue)) continue; const { line, lineNumber } = findContextLine(content, match.index);
                    allFindings.push({ t: pt.type, l: pt.l, h: pt.h, p: pt.p || 99, v: cleanValue, f: fileName, ctx: `L${lineNumber}: ${line}` }); }
            } else if (pt.mt === 'line') { lines.forEach((lineContent, index) => { regex.lastIndex = 0; if (regex.test(lineContent)) { const cleanValue = lineContent.trim();
                        if (cleanValue && (!pt.f || pt.f(cleanValue))) { allFindings.push({ t: pt.type, l: pt.l, h: pt.h, p: pt.p || 99, v: cleanValue, f: fileName, ctx: `Line ${index + 1}` }); } } });
            } else { while ((match = regex.exec(content)) !== null) { const matchedValue = (match.length > 1 && match[1]) ? match[1] : match[0]; if (matchedValue) { const cleanValue = matchedValue.trim();
                        if (cleanValue.length < 3 || (pt.f && !pt.f(cleanValue))) continue; if (isDex && cleanValue.length > 150 && !/[\s/:=\.\-\\]/.test(cleanValue) && !pt.l.includes("Base64") && !pt.l.includes("Entropy")) continue;
                        const { line, lineNumber } = findContextLine(content, match.index);
                        allFindings.push({ t: pt.type, l: pt.l, h: pt.h, p: pt.p || 99, v: cleanValue, f: fileName, ctx: `L${lineNumber}: ${line}` }); }
                    if (regex.lastIndex === match.index) regex.lastIndex++; } }
        } catch (e) { console.warn(`Regex error on ${fileName} for pattern ${pt.l}: ${e.message}`); }
    } }

function displayManifestInfo(content) {
     manifestInfoContainer.style.display = 'block'; manifestInfoContainer.innerHTML = '<h3>AndroidManifest.xml Info (Basic)</h3>'; if (!content) { manifestInfoContainer.innerHTML += '<p class="no-findings">Could not read or parse Manifest.</p>'; return; }
     try { let pkg = content.match(/package="([^"]+)"/); let vc = content.match(/android:versionCode="([^"]+)"/); let vn = content.match(/android:versionName="([^"]+)"/);
         let dbgMatch = content.match(/android:debuggable="(true|false)"/); let dbg = dbgMatch ? dbgMatch[1] === 'true' : null; let infoHtml = "<ul>";
         if(pkg) infoHtml += `<li><strong>Package:</strong> ${escapeHtml(pkg[1])}</li>`; if(vn) infoHtml += `<li><strong>Version Name:</strong> ${escapeHtml(vn[1])}</li>`; if(vc) infoHtml += `<li><strong>Version Code:</strong> ${vc[1]}</li>`;
         if(dbg !== null) { infoHtml += `<li><strong>Debuggable:</strong> <span class="${dbg ? 'debuggable-true' : ''}">${dbg}</span></li>`; } else { infoHtml += `<li><strong>Debuggable:</strong> Not Found (Defaults false)</li>`; }
         infoHtml += "</ul>"; manifestInfoContainer.innerHTML += infoHtml;
     } catch (e) { manifestInfoContainer.innerHTML += '<p class="no-findings">Error during basic Manifest parsing.</p>'; console.error("Manifest basic parse error:", e); } }


async function displayFindings(allFindings, startTime, totalFilesScanned) {
    resultsContent.innerHTML = ''; lastAnalysisResults = null; copyAllButton.style.display = 'none';
    if (allFindings.length === 0) { resultsContent.innerHTML = '<p class="no-findings">No specific patterns found.</p>';
        const duration = ((performance.now() - startTime) / 1000).toFixed(2);
        scanFooterText.textContent = `Scan completed in ${duration}s. Scanned ${totalFilesScanned} files. No findings.`; return; }
    progressText.textContent = `Grouping ${allFindings.length} findings...`; await new Promise(r => setTimeout(r, 0));
    const groupedFindings = {};
    allFindings.forEach(f => { const key = `${f.p}::${f.l}::${f.v}`; if (!groupedFindings[key]) { groupedFindings[key] = { ...f, files: new Set(), contexts: new Map() }; }
        groupedFindings[key].files.add(f.f); if (!groupedFindings[key].contexts.has(f.f)) { groupedFindings[key].contexts.set(f.f, new Set()); }
        if (groupedFindings[key].contexts.get(f.f).size < 3) { groupedFindings[key].contexts.get(f.f).add(f.ctx); } });
    const uniqueFindings = Object.values(groupedFindings);
    uniqueFindings.sort((a, b) => a.p - b.p || a.l.localeCompare(b.l) || a.v.localeCompare(b.v));
    const sections = {};
    uniqueFindings.forEach(f => { if (!sections[f.l]) sections[f.l] = { label: f.l, highlight: f.h, priority: f.p, items: [] }; sections[f.l].items.push(f); });
    const sortedSectionKeys = Object.keys(sections).sort((a, b) => sections[a].priority - sections[b].priority);
    lastAnalysisResults = { sections, sortedSectionKeys }; let totalDisplayedItems = 0;
    progressText.textContent = `Rendering ${uniqueFindings.length} unique findings...`; await new Promise(r => setTimeout(r, 5));
    for (const label of sortedSectionKeys) { const sectionData = sections[label]; const sectionDiv = document.createElement('div'); sectionDiv.className = 'finding-section';
        sectionDiv.innerHTML = `<h3>${escapeHtml(sectionData.label)} <span class="count-badge ${sectionData.highlight}">${sectionData.items.length}</span></h3>`;
        const ul = document.createElement('ul'); const fragment = document.createDocumentFragment();
        for (let i = 0; i < sectionData.items.length; i++) { const item = sectionData.items[i]; const li = document.createElement('li');
            const displayValue = item.v.length > MAX_DISPLAY_VALUE_LEN ? escapeHtml(item.v.substring(0, MAX_DISPLAY_VALUE_LEN)) + '...' : escapeHtml(item.v);
            const fileList = Array.from(item.files); const filesShown = fileList.slice(0, MAX_FILES_PER_FINDING_DISPLAY).map(escapeHtml).join(', ');
            const filesExtra = fileList.length > MAX_FILES_PER_FINDING_DISPLAY ? ` & ${fileList.length - MAX_FILES_PER_FINDING_DISPLAY} more...` : '';
            let contextSample = ''; if (item.contexts.size > 0) { const firstFileName = item.contexts.keys().next().value; const firstFileContexts = Array.from(item.contexts.get(firstFileName));
                 contextSample = `<br><i>Context (${escapeHtml(firstFileName)}): ${escapeHtml(firstFileContexts[0].substring(0, 150))}</i>`; if (firstFileContexts[0].length > 150) contextSample += '...'; }
            const valueSpan = document.createElement('span'); valueSpan.className = `finding-value ${item.h}`; valueSpan.title = `Click to copy value: ${escapeHtml(item.v)}`; valueSpan.textContent = displayValue;
            valueSpan.onclick = () => { navigator.clipboard.writeText(item.v).then(() => console.log('Copied:', item.v)).catch(err => console.error('Copy failed:', err)); };
            li.appendChild(valueSpan); li.innerHTML += `<span class="finding-location">(in ${filesShown}${filesExtra}) ${contextSample}</span>`;
            fragment.appendChild(li); totalDisplayedItems++;
            if (i > 0 && i % RENDER_BATCH_SIZE === 0) { progressText.textContent = `Rendering: ${totalDisplayedItems} / ${uniqueFindings.length}...`; await new Promise(r => setTimeout(r, 0)); } }
        ul.appendChild(fragment); sectionDiv.appendChild(ul); resultsContent.appendChild(sectionDiv); }
    const duration = ((performance.now() - startTime) / 1000).toFixed(2);
    scanFooterText.textContent = `Scan completed in ${duration}s. Found ${allFindings.length} total (${uniqueFindings.length} unique) patterns in ${totalFilesScanned} scanned files.`;
    progressText.textContent = 'Rendering complete.'; copyAllButton.style.display = 'inline-block';
}

function copyAllResultsToClipboard() {
    if (!lastAnalysisResults || !lastAnalysisResults.sections) { console.warn("No results available to copy."); return; }
    let fullText = `APK Scan Results (${selectedFile ? selectedFile.name : 'Unknown File'})\n========================================\n\n`;
    for (const label of lastAnalysisResults.sortedSectionKeys) { const sectionData = lastAnalysisResults.sections[label];
        fullText += `## ${sectionData.label} (${sectionData.items.length} unique) ##\n\n`;
        sectionData.items.forEach(item => { fullText += `Value: ${item.v}\nFound In: ${Array.from(item.files).join(', ')}\n---\n`; }); fullText += "\n"; }
    navigator.clipboard.writeText(fullText).then(() => { console.log('All results copied to clipboard.'); const originalText = copyAllButton.textContent; copyAllButton.textContent = 'Copied!';
        setTimeout(() => { copyAllButton.textContent = originalText; }, 2000); }).catch(err => { console.error('Failed to copy all results:', err); errorMessage.textContent = 'Error: Could not copy results to clipboard.'; }); }

fileInput.addEventListener('change', (e) => {
    selectedFile = e.target.files[0]; resetUI();
    if (selectedFile && selectedFile.name.toLowerCase().endsWith('.apk')) { analyzeButton.disabled = false; fileNameDisplay.textContent = selectedFile.name; }
    else { analyzeButton.disabled = true; const message = selectedFile ? 'Select valid .apk file' : 'No file chosen'; fileNameDisplay.textContent = message; selectedFile = null;
        if (e.target.files.length > 0 && !e.target.files[0].name.toLowerCase().endsWith('.apk')) { errorMessage.textContent = 'Error: File is not .apk'; } } });

analyzeButton.addEventListener('click', async () => {
    if (!selectedFile || isAnalyzing) return; isAnalyzing = true; setLoadingState(true); let allFindings = []; let totalFiles = 0; let filesProcessed = 0; let filesScanned = 0; const startTime = performance.now(); let manifestContent = null;
    try { progressText.textContent = 'Loading APK file...'; const zip = await JSZip.loadAsync(selectedFile); const filesToProcess = Object.values(zip.files).filter(f => !f.dir); totalFiles = filesToProcess.length; progressText.textContent = `Identifying ${totalFiles} files...`; await new Promise(r => setTimeout(r, 0));
        const filePromises = [];
        for (const file of filesToProcess) { const fileName = file.name; let readType = null; let isDex = false;
            if (fileName === 'AndroidManifest.xml') { readType = 'text'; }
            else if (fileName.match(/^classes\d*\.dex$/i)) { readType = 'buffer'; isDex = true; }
            else if (isInterestingTextFileName(fileName) || fileName.startsWith("assets/") || fileName.startsWith("res/raw/")) { readType = 'text'; }
            if (readType) { filePromises.push({ file, readType, isDex, fileName }); } }

        progressText.textContent = `Reading ${filePromises.length} relevant files...`; await new Promise(r => setTimeout(r, 0));
        for (const item of filePromises) { filesProcessed++; progressText.textContent = `Scanning: ${filesProcessed}/${filePromises.length} (${item.fileName.substring(0, 50)}...)`; let content = null;
            try {
                if (item.readType === 'text') { content = await item.file.async("text"); }
                else if (item.readType === 'buffer') { const buffer = await item.file.async("arraybuffer"); content = extractStringsFromBuffer(buffer, MIN_STRING_LEN_DEX); }

                if (content) { filesScanned++;
                    if (item.fileName === 'AndroidManifest.xml') { manifestContent = content; displayManifestInfo(manifestContent); }
                    scanContent(content, item.fileName, item.isDex, allFindings);
                }
            } catch (e) { console.warn(`Could not process file ${item.fileName}: ${e.message}`); if (item.fileName === 'AndroidManifest.xml') manifestContent = null; }
            if (filesProcessed % ANALYSIS_YIELD_INTERVAL === 0) { await new Promise(r => setTimeout(r, 0)); } // Yield to UI thread periodically
        }

        if (!manifestContent) { displayManifestInfo(null); } // Ensure manifest section shows even if read failed
        await displayFindings(allFindings, startTime, filesScanned);
    } catch (error) { errorMessage.textContent = `Fatal Error: ${error.message}`; resultsContent.innerHTML = '<p class="error">Failed to process APK.</p>'; console.error("Analysis error:", error);
    } finally { setLoadingState(false); isAnalyzing = false; } });

copyAllButton.addEventListener('click', copyAllResultsToClipboard);

function setLoadingState(isLoading) {
    analyzeButton.disabled = isLoading; fileInput.disabled = isLoading; loader.style.display = isLoading ? 'block' : 'none';
    if (isLoading) { errorMessage.textContent = ''; scanFooterText.textContent = ''; resultsHeader.textContent = "Results:"; manifestInfoContainer.style.display = 'none'; manifestInfoContainer.innerHTML = '';
        resultsContent.innerHTML = ''; resultsPlaceholder.style.display = 'none'; copyAllButton.style.display = 'none'; lastAnalysisResults = null; } }

function resetUI() {
    errorMessage.textContent = ''; progressText.textContent = ''; scanFooterText.textContent = ''; resultsHeader.textContent = "Results:";
    resultsContent.innerHTML = '<p id="results-placeholder" class="results-placeholder">Ready. Select APK file.</p>';
    manifestInfoContainer.style.display = 'none'; manifestInfoContainer.innerHTML = ''; copyAllButton.style.display = 'none'; lastAnalysisResults = null; }

resetUI();
</script>
</body>
</html>
